// deno-lint-ignore-file no-explicit-any
import type { OpenAPI, OpenAPIDefaultSchema } from "@/src/OpenAPI/index.ts";
import type { NewEndpointParams, OpenAPIParams } from "@/src/OpenAPI/index.ts";
import { inp, YelixValidationBase } from "@/mod.ts";

class YelixOpenAPI {
  _openAPI: OpenAPI | null = null;
  private customValidationDescriptions: Record<string, (_: any) => string> = {};

  constructor(params: OpenAPIParams) {
    this._openAPI = {
      openapi: "3.1.0",
      info: {
        title: params.title,
        version: params.version,
        description: params.description || "Yelix API Documentation",
      },
      paths: {},
      servers: params.servers || [],
    };
  }

  customValidationDescription(kind: string, fn: (_: any) => string): boolean {
    let isOverriding = false;

    if (this.customValidationDescriptions[kind]) {
      isOverriding = true;
    }

    this.customValidationDescriptions[kind] = fn;
    return isOverriding;
  }

  getCustomValidationDescription(kind: string): (_: any) => string {
    return this.customValidationDescriptions[kind];
  }

  getJSON(): OpenAPI {
    return this._openAPI!;
  }

  private generateYelixExample(yelixSchema: YelixValidationBase): any {
    const typeRule = yelixSchema.rules.find((r) => r.title === "isValidType");
    if (!typeRule) return null;

    const type = typeRule.value;
    const isDatetime = yelixSchema.rules.some((r) => r.title === "datetime");

    if (type === "string") {
      if (isDatetime) return new Date().toISOString();
      return "example string";
    }
    if (type === "number") return 42;
    if (type === "boolean") return true;
    if (type === "file") return "example.txt";

    if (type === "object" && "subFields" in yelixSchema) {
      const example: Record<string, any> = {};
      for (
        const [key, subSchema] of Object.entries(
          yelixSchema.subFields as Record<string, YelixValidationBase>,
        )
      ) {
        example[key] = this.generateYelixExample(subSchema);
      }
      return example;
    }

    if (type === "array") {
      const arrayTypeRule = yelixSchema.rules.find((r) =>
        r.title === "arrayType"
      );
      if (arrayTypeRule && arrayTypeRule.value) {
        return [this.generateYelixExample(arrayTypeRule.value)];
      }
      return ["example"];
    }
    return null;
  }

  private yelixZodToJsonSchema(
    yelixSchema: YelixValidationBase,
  ): OpenAPIDefaultSchema {
    const schema: OpenAPIDefaultSchema = { type: "string" };

    for (const rule of yelixSchema.rules) {
      if (rule.title === "isValidType") {
        const type = rule.value;
        if (type === "string") schema.type = "string";
        else if (type === "number") schema.type = "number";
        else if (type === "boolean") schema.type = "boolean";
        else if (type === "date") schema.type = "string";
        else if (type === "file") schema.type = "string";
        else if (type === "array") schema.type = "array";
        else if (type === "object") {
          schema.type = "object";
          if ("subFields" in yelixSchema) {
            schema.properties = {};
            for (
              const [key, subSchema] of Object.entries(
                yelixSchema.subFields as Record<string, YelixValidationBase>,
              )
            ) {
              schema.properties[key] = this.yelixZodToJsonSchema(subSchema);
            }
          }
        }
      }
    }

    return schema;
  }

  private getParamsFromPath(path: string) {
    return [...path.matchAll(/{([a-zA-Z0-9_]+)}/g)].map((match) => match[1]);
  }

  addNewEndpoint(apiDoc: NewEndpointParams) {
    if (!this._openAPI) {
      throw new Error("OpenAPI not initialized");
    }

    const { path, method } = apiDoc;
    const defaultSummary = `${method.toUpperCase()} ${path}`;

    const responses: Record<string, any> = {};
    const responseStatusCodes = Object.keys(apiDoc.responses || {});
    for (const statusCode of responseStatusCodes) {
      const response = apiDoc.responses![statusCode];

      responses[statusCode] = {
        description: response.description,
        content: {
          [response.type]: {
            schema: this.yelixZodToJsonSchema(
              response.zodSchema || inp().string(),
            ),
            examples: {
              autoGenerated: this.generateYelixExample(
                response.zodSchema || inp().string(),
              ),
            },
          },
        },
      };
    }

    const parameters = [];
    const queries = apiDoc.validation?.query;

    const params = this.getParamsFromPath(path);
    for (const param of params) {
      parameters.push({
        name: param,
        in: "path",
        required: true,
        schema: {
          type: "string",
        },
      });
    }

    if (queries) {
      for (const key in queries) {
        const query = queries[key];
        const queryDescription = apiDoc.query?.[key]?.description;
        let queryDefaultDescription = ""; // Markdown

        if (query instanceof YelixValidationBase) {
          queryDefaultDescription += "###### Validation Rules\n";

          const zodRules = query.rules || [];
          for (const rule of zodRules) {
            const customDescription = this.getCustomValidationDescription(
              rule.title,
            );

            if (customDescription) {
              queryDefaultDescription += customDescription(rule.value) + "\n";
            } else {
              queryDefaultDescription += "- " +
                rule.title +
                (rule.value ? ": " + rule.value : "") +
                "\n";
            }
          }
        }

        parameters.push({
          name: key,
          in: "query",
          required: query.hasRule("required"),
          schema: this.yelixZodToJsonSchema(query),
          description: queryDescription || queryDefaultDescription,
        });
      }
    }

    const lowerMethod = method.toLowerCase();
    this._openAPI.paths![path] = {
      [lowerMethod]: {
        tags: apiDoc.tags || [],
        summary: apiDoc.title || defaultSummary,
        description: apiDoc.description || "",
        responses: responses,
        parameters,
      },
    };
  }
}

export { YelixOpenAPI };
